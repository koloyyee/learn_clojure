(ns pegthing.core
  (:gen-class))

;; Creating a new board
;; Returning a board with the result of the player’s move
;; Representing a board textually
;; Handling user interaction

;; (require [clojure.set :as set]) allows you to easily use functions in the clojure.set namespace
;; (:gen-class) allows you to run the program from the command line,
(declare successful-move prompt-move game-over query-rows)
;; (declare successful-move prompt-move game-over query-rows) 
;; allows functions to refer to those names before they’re defined

;; :connections, a map where each key identifies a legal destination
;; pegs in position 1, for example, can jump to position 6 over position 3
{1  {:pegged true, :connections {6 3, 4 2}},
 2  {:pegged true, :connections {9 5, 7 4}},
 3  {:pegged true, :connections {10 6, 8 5}},
 4  {:pegged true, :connections {13 8, 11 7, 6 5, 1 2}},
 5  {:pegged true, :connections {14 9, 12 8}},
 6  {:pegged true, :connections {15 10, 13 9, 4 5, 1 3}},
 7  {:pegged true, :connections {9 8, 2 4}},
 8  {:pegged true, :connections {10 9, 3 5}},
 9  {:pegged true, :connections {7 8, 2 5}},
 10 {:pegged true, :connections {8 9, 3 6}},
 11 {:pegged true, :connections {13 12, 4 7}},
 12 {:pegged true, :connections {14 13, 5 8}},
 13 {:pegged true, :connections {15 14, 11 12, 6 9, 4 8}},
 14 {:pegged true, :connections {12 13, 5 9}},
 15 {:pegged true, :connections {13 14, 6 10}},
 :rows 5}

;; The first few expressions in this section of the code deal with triangular numbers. 
;; Triangular numbers are generated by adding the first n natural numbers. 
;; The first triangular number is 1, the second is 3 (1 + 2), 
;; the third is 6 (1 + 2 + 3), and so on. 
;; These numbers line up nicely with the position numbers 
;; at the end of every row on the board, 
;; which will turn out to be a very useful property. 
;; First, you define the function tri*, 
;; which can create a lazy sequence of triangular numbers

(defn tri*
  "Generates lazy sequence of triangular numbers"
  ([] (tri* 0 1))  ;; No-argument version calls the two-argument version with initial values
  ([sum n]         ;; Two-argument version
   (let [new-sum (+ sum n)]  ;; Calculate the new sum by adding the current sum and n
     (cons new-sum (lazy-seq (tri* new-sum (inc n)))))))  ;; Construct the lazy sequence

;; tri* with no arguments will recursively call (tri* 0 1). 
;; This returns a lazy list whose element is new-sum, which in this case evaluates to 1.
;; The lazy list includes a recipe for generating the next element of the list when it’s requested

(def tri (tri*))
(take 5 tri)

(defn triangular?
  "Is the number triangular? e.g. 1, 3, 6, 10, 15, etc"
  [n]
  (= n (last (take-while #(>= n %) tri))))

;; row-tri, which takes a row number and gives you the triangular number at the end of that row:
(defn row-tri
  "the triangualr number at the end of row n "
  [n]
  (last (take n tri)))

(row-tri 5)
;; row-num, which takes a board position and returns the row that it belongs to: 
(defn row-num
  "Returns row number the position belongs to: pos 1 in row 1, positions 2 and 3 in row 2, etc"
  [pos]
  (inc (count (take-while #(> pos %) tri))))

(row-num 5)


;; this connects the points to together into a nested map
;; board is {} 
(defn connect
  "Form a mutual connection between two positions"
  [board max-pos pos neighbor destination]
;; 1. check whether the destination is actually a position on the board by confirming that 
;; it's less than the board's max position
  (if (<= destination max-pos)
	;; connect uses recursion through reduce to progressively build up the final state of the board.
    (reduce (fn [new-board [p1 p2]]
              (assoc-in new-board [p1 :connections p2] neighbor))
            board [[pos destination] [destination pos]])
    board))
;; assoc-in lets you return a new map with the given value at the specified nesting
(assoc-in {} [:cookie :monster :vocals] "Finntroll")
;; get-in lets you look up values in nested maps
(get-in {:cookie {:monster {:vocals "Finntroll"}}} [:cookie :monster])

(assoc-in {} [1 :connection 4] 2)

;; we need to connect the right, down-left, and down-right
(defn connect-right
  [board max-pos pos]
  (let [neighbor (inc pos)
        destination (inc neighbor)]
    (if-not (or (triangular? neighbor) (triangular? pos))
      (connect board max-pos pos neighbor destination)
      board)))

(defn connect-down-left
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ row pos)
        destination (+ 1 row neighbor)]
    (connect board max-pos pos neighbor destination)))

(defn connect-down-right
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ 1 row pos)
        destination (+ 2 row neighbor)]
    (connect board max-pos pos neighbor destination)))

(connect-down-left {} 15 1)
;;  => {1 {:connections {4 2}
;;       4 {:connections {1 2}}}}

(connect-down-right {} 15 3)
; => {3  {:connections {10 6}}
      ;; 10 {:connections {3 6}}}

;; actually reduces on a vector of functions, 
;; applying each in turn to build up the resulting board. 
(defn add-pos
  "Pegs the position and performs connections"
  [board max-pos pos]
  (let [pegged-board (assoc-in board [pos :pegged] true)]
    (reduce (fn [new-board connection-creation-fn]
              (connection-creation-fn new-board max-pos pos))
            pegged-board
            [connect-right connect-down-left connect-down-right])))
;; pegged-board binding, 
;; “Add a peg to the board at position X.” Then, 
;; in reduce, it says, “Take the board with its new peg at position X, 
;; and try to connect position X to a legal, rightward position. 
;; Take the board that results from that operation, 
;; and try to connect position X to a legal, down-left position. 
;; Finally, take the board that results from that operation, 
;; and try to connect position X to a legal, down-right position.
;; Return the resulting board.”
(add-pos {} 15 1)

(defn new-board
  "Creates a new board with the given number of rows"
  [rows]
  (let [initial-board {:row rows}
        max-pos (row-tri rows)]
    (reduce (fn [board pos] (add-pos board max-pos pos)) initial-board
            (range 1 (inc max-pos)))))

(defn pegged?
  "Does the position have a peg in it?"
  [board pos]
  (get-in board [pos :pegged]))
(defn remove-peg
  "Take the peg at give position out of the board"
  [board pos]
  (assoc-in board [pos :pegged] false))

(defn place-peg
  "Put a pef in the board at given position"
  [board pos]
  (assoc-in board [pos :pegged] true))

(defn move-peg
"Take peg out of p1 and place it in p2"
[board p1 p2]
(place-peg (remove-peg board p1) p2))